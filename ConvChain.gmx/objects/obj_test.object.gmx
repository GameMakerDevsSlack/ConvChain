<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create

test_iterations       = 100;
test_iterations_sum   = 0;
test_seed             = 1;
test_pattern_size     = 3;
test_variance         = 0.5;
test_output_size      = 80;
test_multidirectional = false;

srf_sample = noone;
srf_regions = noone;

test_regen = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Step

if ( !surface_exists( srf_sample ) ) {
    test_regen = true;
    srf_sample = surface_create( sprite_get_width( spr_sample ), sprite_get_height( spr_sample ) );
    surface_set_target( srf_sample );
    draw_sprite( spr_sample, 0, 0, 0 );
    surface_reset_target();
}

if ( !surface_exists( srf_regions ) ) {
    test_regen = true;
    srf_regions = surface_create( 32, 32 );
    surface_set_target( srf_regions );
    draw_clear( background_colour );
    surface_reset_target();
}

if ( surface_exists( srf_sample ) ) {
    
    var _grid_x = ( mouse_x - 10 ) div 10;
    var _grid_y = ( mouse_y - 10 ) div 10;
    
    if ( point_in_rectangle( _grid_x, _grid_y,   0, 0, surface_get_width( srf_sample )-1, surface_get_height( srf_sample )-1 ) ) {
        
        if ( mouse_check_button( mb_left ) ) {
            surface_set_target( srf_sample );
            draw_point_colour( _grid_x, _grid_y, c_white );
            surface_reset_target();
        }
        
        if ( mouse_check_button( mb_right ) ) {
            surface_set_target( srf_sample );
            draw_point_colour( _grid_x, _grid_y, c_black );
            surface_reset_target();
        }
        
    }
    
    if ( keyboard_check_pressed( ord( "N" ) ) ) {
        
        surface_set_target( srf_sample );
        var _surface_width  = surface_get_width( srf_sample );
        var _surface_height = surface_get_height( srf_sample );
        
        for( var _y = 0; _y &lt; _surface_height; _y++ ) {
            for( var _x = 0; _x &lt; _surface_width; _x++ ) {
                if ( surface_getpixel( srf_sample, _x, _y ) ) draw_point_colour( _x, _y, c_black ) else draw_point_colour( _x, _y, c_white );
            }
        }
        surface_reset_target();
    }
    
    if ( keyboard_check_pressed( ord( "S" ) ) ) { test_seed = irandom_range( -(1&lt;&lt;31), 1&lt;&lt;32 ); test_regen = true; }
    if ( keyboard_check_pressed( vk_up      ) ) test_iterations = clamp( test_iterations + 10, 1, 200 );
    if ( keyboard_check_pressed( vk_down    ) ) test_iterations = clamp( test_iterations - 10, 1, 200 );
    if ( keyboard_check_pressed( vk_left    ) ) test_variance = clamp( test_variance - 0.1, 0, 1 );
    if ( keyboard_check_pressed( vk_right   ) ) test_variance = clamp( test_variance + 0.1, 0, 1 );
    if ( keyboard_check_pressed( ord( "U" ) ) ) { test_multidirectional = !test_multidirectional; test_regen = true; }
    
    if ( keyboard_check_pressed( ord( "R" ) ) ) or ( test_regen ) {
        test_regen = true;
        test_iterations_sum = 0;
        random_set_seed( test_seed );
        grd_sample = conv_surface_to_grid( srf_sample );
        convchain_sample = conv_create( grd_sample, test_pattern_size, test_variance, test_output_size, test_multidirectional );
        conv_randomise( convchain_sample );
        grd_regions = ds_grid_regionize( convchain_sample[? "field" ] );
        region_count = global.ds_grid_regionize_regions;
        srf_regions = ds_grid_regions_to_surface( grd_regions, region_count );
        test_iterations_sum += test_iterations;
        test_regen = false;
    }
    
    if ( keyboard_check( vk_space ) ) {
        conv_iterate( convchain_sample, test_iterations );
        grd_regions = ds_grid_regionize( convchain_sample[? "field" ] );
        region_count = global.ds_grid_regionize_regions;
        srf_regions = ds_grid_regions_to_surface( grd_regions, region_count );
        test_iterations_sum += test_iterations;
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw

var _size = test_output_size*9;

draw_surface_ext( srf_regions,
                  room_width - 10 - _size, 0.5*( room_height - _size ),
                  9, 9, 0, c_white, 1 );

draw_surface_ext( srf_sample, 10, 10,   10, 10, 0,   c_white, 1 );

draw_set_font( fnt_default );
draw_set_colour( c_white );

var _str = "[R]=regen";
_str += "#[Space]=iterate";
_str += "#[N]=invert";
_str += "#[S]=new seed";
_str += "#[Lmb/Rmb]=draw";
_str += "#[Up/Down]=iterations/tick (" + string( test_iterations ) + ")";
_str += "#[Left/Right]=variance";
_str += "#[U]=directionality";
_str += "##seed=" + string( test_seed );
_str += "#total iterations=" + string( test_iterations_sum );
_str += "#variance=" + string( test_variance );
_str += "#pattern size=" + string( test_pattern_size );
if ( test_multidirectional ) _str += "#multidirectional" else _str += "#unidirectional";

var _y = surface_get_height( srf_sample );
draw_set_colour( c_black );
draw_text( 11, _y*10 + 21, _str );
draw_set_colour( c_white );
draw_text( 10, _y*10 + 20, _str );
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
